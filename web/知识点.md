# 知识点

## Webhooks/web 钩子

`webhook是在特定情况下触发的一种api（回调），用于在项目发生相关事件时通知外部服务器。这些回调由第三方的用户、开发人员自己定义、维护、管理，就好像允许别人挂载一条网线到你的Web网站或者应用程序的钩子上，来实时地收到你的推送信息`

比方说我的网站有一个api `http://dev.lovelucy.info/incoming`，负责接受一个 Post 请求。每次有push 事件时 GitHub 都会主动往这个地址发送一个 POST 请求。当然 GitHub 还有个 Secret 的设定，就是一个字符串，如果加上的话就在 POST 请求的 HTTP 头中会带一个 Hash 值做验证密文，证明这个 POST 真是来自 GitHub。

再比方，在js中，target.addEventListener(type, listener[, options]);可以为一个节点添加一个事件，如：

```js
document.getElementById("myBtn").addEventListener("click", function(){
    document.getElementById("demo").innerHTML = "Hello World";
});
```

在点击myBtn按钮时候，会触发点击事件。同理webhook也是如此，在git操作中使用频繁。

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1gasdo0kz3uj30pe0jwjtw.jpg)

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1gasdoikbhoj30lq0c8q3s.jpg)

**Webhook 处理管道**：

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1gasdhum1e5j30jp092my2.jpg)

其中 DropBox、PayPal、Github、Slack都是第三方平台，这些平台接受到某些 HTTP 请求后，触发 Web Hook 发送新的 HTTP 请求到 Your Web Site， Your Web Site 收到来自第三方平台的 HTTP 请求后再进行自己的业务处理

**例子**：我的系统属于后台接口系统。每次我开发提交完git仓库后要实时的部署到测试环境，这时候就可以用到gitlab或github的web hooks进行自动更新部署。当我push代码后，触发 gitlab/github 的 web hook 发送 post 请求到我的后台接口系统，后台接口系统接收到该 post 请求后就开始进行更新部署。

**参考**：

- [钩子(hooks)—webhook-使用钩子自动触发部署](https://blog.csdn.net/feng98ren/article/details/81737287)

- [WebHooks - Web钩子](http://www.mamicode.com/info-detail-2257739.html)

- [了解Webhooks](https://blog.csdn.net/tengxing007/article/details/78749381)

---

## Swagger

`Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。允许接口文档在线自动生成，以及功能测试。总体目标是使客户端和作为服务器的文件系统以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。`

通过将相关的信息存储在它定义的描述文件里面(yml或json格式)，然后维护这个描述文件可以去更新接口文档，以及生成各端代码。而java 中的 Springfox-swagger，则可以通过扫描代码去生成这个描述文件，连描述文件都不需要再去维护了。所有的信息，都在代码里面了。代码即接口文档，接口文档即代码。

比方 gitea 集成 Swagger 生成的 gitea API。[https://try.gitea.io/api/swagger](https://try.gitea.io/api/swagger)

**参考**：

- [Swagger](https://www.jianshu.com/p/a0caf58b3653)

- [swagger是什么](https://www.yunqishi.net/dnjc/dnzx/35732.html)

- [Swagger介绍及使用](https://www.jianshu.com/p/349e130e40d5)

---

## 本地化

软件本地化是指改编软件产品的功能、用户界面 (UI)、联机帮助和文档资料等，使之适合目标市场的特定文化习惯和文化偏好。软件本地化服务范围：软件资源翻译排版、用户界面本地化、用户界面重新设计与调整、联机帮助系统本地化、功能增强与调整、功能测试及翻译测试、翻译自动化和产品本地化管理、程序文字本地化、医疗软件本地化、机械电子软件本地化、组态软件本地化、游戏本地化、手机软件本地化、商务软件本地化、工程软件本地化等。

Gitea 中的本地化就是变量名对应的本地语言解释，位于`conf/local/` 中。如中文本地化：

![image.png](http://ww1.sinaimg.cn/large/006alGmrgy1gasy6su1k4j31nj0vpqds.jpg)

**参考**：

- [本地化](https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E5%8C%96/2886793)

- [应用本地化](https://go-macaron.com/zh-cn/middlewares/i18n)

---

## ORM（Object Relational Mapping） 对象关系映射

ORM：对象关系映射（Object Relational Mapping，简称ORM）,目的是想像操作对象一样操作数据库.因为数据库不是面向对象的,所以需要编程进行映射.

RM方法论基于三个核心原则：

1. 简单：以最基本的形式建模数据。

2. 传达性：数据库结构被任何人都能理解的语言文档化。

3. 精确性：基于数据模型创建正确标准化了的结构

java 中常见的ORM框架有hibernate,半自动orm框架有mybatis,还有新的简单易用的bee框架.

go 中常见的 ORM 框架有 `xorm`

**参考**：[ORM是什么](https://zhidao.baidu.com/question/449296833.html)

---

## OpenID

OpenID是一个去中心化的网上身份认证系统。对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（identity provider, IdP）的网站上注册。OpenID是去中心化的，任何网站都可以使用OpenID来作为用户登录的一种方式，任何网站也都可以作为OpenID身份提供者。OpenID既解决了问题而又不需要依赖于中心性的网站来确认数字身份。

OpenID 系统的第一部分是身份验证，即如何通过 URI 来认证用户身份。目前的网站都是依靠用户名和密码来登录认证，这就意味着大家在每个网站都需要注册用户名和密码，即便你使用的是同样的密码。如果使用 OpenID ，你的网站地址（URI）就是你的用户名，而你的密码安全的存储在一个 OpenID 服务网站上（你可以自己建立一个 OpenID 服务网站，也可以选择一个可信任的 OpenID 服务网站来完成注册）。

登录一个支持 OpenID 的网站非常简单（即便你是第一次访问这个网站也是一样）。只需要输入你注册好的 OpenID 用户名，然后你登录的网站会跳转到你的 OpenID 服务网站，在你的 OpenID 服务网站输入密码（或者其它需要填写的信息）验证通过后，你会回到登录的网站并且已经成功登录。OpenID 系统可以应用于所有需要身份验证的地方，既可以应用于单点登录系统，也可以用于共享敏感数据时的身份认证。

`除了一处注册，到处通行以外，OpenID 给所有支持 OpenID 的网站带来了价值—共享用户资源。用户可以清楚的控制哪些信息可以被共享，例如姓名、地址、电话号码等。`

**使用案例**：使用 OpenID 登录 [gitea](https://gitea.com/user/login/openid)。用户名为 `http://qiubing.openid.org.cn/`

==注意，微信中的 OpenID 有不一样的使用方式。微信中 OpenID,一个互联网用户的身份标识。对于公众号来说，每一个用户，都有一个OpenID。此外每个用户对每个公众号的OpenID是唯一的。然而对于不同公众号或服务，同一用户的OpenID是不同的。==

**参考**：

- [OpenID](https://baike.baidu.com/item/OpenID/2267230?fr=aladdin)

- [为什么会是OpenID?](https://www.jianshu.com/p/4335a25fa98d)

---
