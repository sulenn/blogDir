[toc]

# 知识点

## TCP 和 UDP 的区别

1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

4. TCP首部开销20字节;UDP的首部开销小，只有8个字节

---

## TCP 三次握手和四次挥手，为什么

- 为什么是两次握手不是三次握手（下面链接里面的答案不对，这里的才是对的）

    三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。 

- [TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809)

---

## 为什么tcp三次握手的时候的seq初始化时随机地，而不是从0开始

tcp三次握手的过程中，如果硬编码，也就是写死seq序列，如果主机A和B频繁的建立连接，传送一些TCP报文后断开链接，如果主机A中一些TCP报文在网络中滞留较长时间，主机A会重传这些报文，链接释放后，重新建立新的链接，那么之前这些滞留较长时间的报文会到达主机B，但是这些报文的链接早就释放了，B应该回复RST。但是由于seq序列写死，每次链接的seq序列都是一致的，那么主机B可能会接受这些过时的，无意义的报文，结果产生错误。

**参考**：[https://www.nowcoder.com/discuss/410212?type=0&order=0&pos=7&page=1](https://www.nowcoder.com/discuss/410212?type=0&order=0&pos=7&page=1)

---

## TCP如何保证传输的可靠性

- 校验和

- 序列号

- 确认应答

- 超时重传

- 连接管理

- 流量控制

- 拥塞控制

**参考**：[网络基础：TCP协议-如何保证传输可靠性](https://blog.csdn.net/liuchenxia8/article/details/80428157)

---

## TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决

**参考**：[网络基础：TCP协议-如何保证传输可靠性](https://blog.csdn.net/liuchenxia8/article/details/80428157)

---

## session 在服务器上以怎样的形式存在

可以存储在内存中。不过也可以做持久化存储。如：文件、数据库等。

**参考**：[Session是怎么实现的？存储在哪里？](https://blog.csdn.net/qq_15096707/article/details/74012116?utm_source=distribute.pc_relevant.none-task)

---

## Http与Https的区别

与 SSL（或TSL）组合使用的 HTTP 被称为 HTTPS

1、https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**参考**：[Http和Https的区别（面试常考题）](https://blog.csdn.net/qq_38289815/article/details/80969419)

---

## http 的缺点

- 通信使用明文（不加密），内容可能会被窃听

- 不验证通信方的身份，因此有可能遭遇伪装

- 无法证明报文的完整性，所以有可能已遭篡改

---

## https 缺点

1. 增加网络负载：https 除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。

2. 提高服务器和客户端的硬件（CPU、内存）资源消耗：另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。

3. 购买证书需要花钱

**可用的解决方案**：针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。

---

## https 是什么

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TL（Transport Layer Security）协议代替而已。

通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gej4vadr6rj314n0ittdk.jpg)

SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。

**参考**：《图解HTTP》

---

## cookie 和 session 的区别

1. 存储位置不同：cookie 存放在客户端浏览器上，session 存放在服务器中

2. 存储容量不同：单个 cookie 保存的数据 <=4k，一个站点最多保存 20 个cookie。session 理论上没有限制，不过为了服务器性能，session 内不要放置过多的东西，且设置 session 删除机制。

3. 隐私策略不同：cookie 对客户端可见，其它人可以分析存放在本地的 cookie 进行 cookie 欺骗。所以它不安全。session 对客户端是透明的，不存在敏感数据泄露的风险。

4. 服务器压力不同：cookie 保存在客户端，不会给服务器造成压力；session 保存在服务端，每个用户都会产生一个 session，耗费大量内存。

5. 跨域支持不同：cookie 支持跨域访问；session 不支持跨域访问。

**参考**：[Cookie和Session的区别](https://www.jianshu.com/p/2f7031a69f43)

---

---

## HTTP状态码分类

- 1**：信息，服务器收到请求，需要请求者继续执行操作

- 2**：成功，操作被成功接收并处理

- 3**：重定向，需要进一步的操作以完成请求

- 4**：客户端错误，请求包含语法错误或无法完成请求

- 5**：服务器错误，服务器在处理请求的过程中发生了错误

**参考**：[HTTP状态码](https://www.runoob.com/http/http-status-codes.html)

---

## Socket 编程

Socket 是一种面向网络的编程方式，它介于应用层和传输层之间。也是计算机网络中用于在节点内发送或接收数据的内部端点。

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gch2wvky1pj30o80i678n.jpg)

**参考**：[socket编程到底是什么？](https://www.zhihu.com/question/29637351/answer/534704474)

---

## http 通信过程

1. 建立TCP连接

2. Web浏览器向Web服务器发送请求命令

3. Web服务器应答

4. Web服务器关闭TCP连接

5. 浏览器接受到服务器响应的数据

**总结流程**：

浏览器发起请求-> 解析域名得到ip进行TCP连接 ->浏览器发送HTTP请求和头信息发送->服务器对浏览器进行应答，响应头信息和浏览器所需的内容-> 关闭TCP连接或保持-> 浏览器得到数据数据进行操作

**参考**：

- [一次完整的HTTP请求所经历的步骤](https://www.jianshu.com/p/ae62574f7a99)

- [更完整的 HTTP 通信过程](https://www.cnblogs.com/ghl1024/p/12080532.html)

---

## HTTP 报文格式

1. 请求报文

    HTTP请求报文由**请求行（request line）、请求头（header）、空行和请求体4个部分组成**。

    空行的作用是通知服务器以下不再有请求头。

    请求行中有**请求方法、URL、http 协议版本**

2. 响应报文

    HTTP响应报文和请求报文的结构类似，也是由四个部分组成：**响应行、消息报头、空行、响应体**。

    响应行也由三部分组成：**服务器HTTP协议版本，响应状态码，状态码的文本描述**

**参考**：

- [HTTP报文格式](https://www.cnblogs.com/Mr-mubai/p/11603520.html)

- [Http协议报文格式](https://www.cnblogs.com/jpfss/p/10984966.html)

---

## https 通信过程

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口

2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3. 服务器将自己的公钥发送给客户端。

4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7. 然后服务器将加密后的密文发送给客户端。

8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gcsphfe9tvj30qq0yi7b9.jpg)

**参考**：

- [Https原理及流程](https://www.jianshu.com/p/14cd2c9d2cd2)

- [HTTPS安全通信过程](https://www.cnblogs.com/xtiger/p/11026870.html)

---

## ssl 和 tls 的区别

**ssl**：SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据，防止网络犯罪分子读取和修改任何传输信息，包括个人资料。

**tls**：TLS（传输层安全Transport Layer Security）是更为安全的升级版 SSL。

**差异**：

1）版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。

　　2）报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法。SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。

　　3）伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式。

　　4）报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。

　　5）密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。

　　6）certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。

　　7）加密计算：TLS与SSLv3.0在计算主密值（master secret）时采用的方式不同。

　　8）填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。

**参考**：

- [HTTPS、SSL、TLS三者之间的联系和区别](https://blog.csdn.net/enweitech/article/details/81781405)

- [SSL与TLS的区别](https://www.cnblogs.com/feng9exe/p/8060349.html)

---

## tls 验证过程

**证书机制/证书验证**：

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gdcuba7xg3j30qd095qb8.jpg)

1. 客户端获取到了站点证书，拿到了站点的公钥；

2. 要验证站点可信后，才能使用其公钥，因此客户端找到其站点证书颁发者的信息；

3. 站点证书的颁发者验证了服务端站点是可信的，但客户端依然不清楚该颁发者是否可信；

4. 再往上回溯，找到了认证了中间证书商的源头证书颁发者。由于源头的证书颁发者非常少，我们浏览器之前就认识了，因此可以认为根证书颁发者是可信的；

5. 一路倒推，证书颁发者可信，那么它所颁发的所有站点也是可信的，最终确定了我们所访问的服务端是可信的；

6. 客户端使用证书中的公钥，继续完成TLS的握手过程。

**客户端可以通过两种方法验证证书的有效性**：

1. **CRL（Certificate Revocation List）即证书撤销名单**:证书颁发者会提供一份已经失效证书的名单，供浏览器验证证书使用。当然这份名单是巨长无比的，浏览器不可能每次TLS都去下载，所以常用的做法是浏览器会缓存这份名单，定期做后台更新。这样虽然后台更新存在时间间隔，证书失效不实时，但一般也OK。

2. **OCSP(Online Certificate StatusProtocol)即在线证书状态协议**:除了离线文件，证书颁发者也会提供实时的查询接口，查询某个特定证书目前是否有效。实时查询的问题在于浏览器需要等待这个查询结束才能继续TLS握手，延迟会更大。

**参考**:[HTTPS加密过程和TLS证书验证](https://www.jianshu.com/p/f6b34381beac)

---

## 应用层协议有哪些

- 域名系统(Domain Name System，DNS)：用于实现网络设备名字到IP地址映射的网络服务。

    ==一般情况下使用UDP进行域名解析服务，也可以用TCP==

    **区域传送时使用TCP，主要有一下两点考虑**：
    1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。
    2.TCP是一种可靠的连接，保证了数据的准确性。

    **域名解析时使用UDP协议：**
    客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

- 文件传输协议(File Transfer Protocol，FTP)：用于实现交互式文件传输功能。

- 简单邮件传送协议(Simple Mail Transfer Protocol, SMTP)：用于实现电子邮箱传送功能。

    使用 TCP 提供可靠数据传输

- 超文本传输协议(HyperText Transfer Protocol，HTTP)：用于实现WWW服务。

- 简单网络管理协议(simple Network Management Protocol，SNMP)：用于管理与监视网络设备。

- 远程登录协议(Telnet)：用于实现远程登录功能。

- 动态主机配置协议（DHCP)：为主机配置IP；包括手动分配、自动分配和动态分配。

**参考**：

- [应用层协议有哪些？](https://zhidao.baidu.com/question/578099657.html)

- [DNS使用的是TCP协议还是UDP协议](https://blog.csdn.net/qq100440110/article/details/50908992)

---

## 动态主机配置协议(DHCP)

对IP地址进行自动设置与统一分配

DHCP服务器可提供三种地址分配：

- 手动分配
    由网络管理员在DHCP服务器手工配置DHCP客户机的IP地址。

- 自动分配
    当DHCP客户机第一次向DHCP服务器请求到IP地址后，这个地址就永久地分配给了该DHCP客户机，不可撤销。

- 动态分配（最常见）
    与自动分配采用相同的方法，只不过获得的IP地址是有租约期限的，一旦租约到期，地址就会被回收，不过可以通过续订租约以延长期限。

**4个阶段**：

- 发现阶段（discover）：

    由于不知DHCP服务器的IP地址和Mac地址，DHCP客户机通过向本地网络广播一个DHCP DISCOVER请求报文以向网络中的DHCP服务器请求网络配置信息。

- 提供阶段（offer）：

    当DHCP服务器收到发现报文，它就从它的地址池中选出一个空闲IP填充到DHCP OFFER的"Your" IP address字段，并在选项字段加上子网掩码，路由器，DNS，服务器标识，IP地址租用时间等字段。再广播此报文（因为此时还不知客户机的IP地址）

- 请求阶段（request）：

    最后客户机可能会收到多个DHCP服务器的DHCP OFFER报文，一般是选最先到达那个报文并作出回应请求，即广播发出一个 包含服务器选项字段的DHCP REQUEST报文。这里还使用广播的目的是因为要让所有的DHCP服务器知道客户机选择了哪个服务器提供的IP。

- ACK阶段：

    DHCP服务器收到来自客户机的DHCP REQUEST报文，而只有符合服务器标识这个选项字段的DHCP服务器才会对此作出响应：

    如果服务器可以分配此IP则以DHCP ACK报文进行响应。
    如果服务器无法分配此IP则以DHCP NAK报文进行响应。

**参考**：[动态主机配置协议(DHCP)](https://www.jianshu.com/p/9b6b17be7413)

---

## HTTP 1.0 、1.1、2.0 区别

**http1.0 和 http2.0 的区别**：

1. 带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分。
2. 服务器Push：服务端可以在客户端某个请求后，主动推送其他资源。
3. 错误通知的管理：在HTTP1.1中新增了24个错误状态响应码
4. ==以前每次 只能发送一个请求，现在可以同时发送多个请求==。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
   所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。

**http2.0 主要基于SPDY协议**。

**SPDY 协议**：目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。

**http1.1的缺点**：

1. HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。

2. 单向请求，只能由客户端发起。

3. 请求报文与响应报文首部信息冗余量大。

4. 数据未压缩，导致数据的传输量大。

5. 可任意选择数据压缩格式。非强制压缩发送。(也可以不压缩)

**http2.0特点**：

1. 二进制传输：在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，==文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮==。
    在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

    ![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1gem1z2ruscj30u40fa43o.jpg)

2. 多路复用：==以前每次 只能发送一个请求，现在可以同时发送多个请求==。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
    所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。

3. Header压缩：在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。
    在HTTP2.0中，我们==使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小==。==并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值==。

4. 服务器Push：服务端可以在客户端某个请求后，主动推送其他资源。

5. 更安全：HTTP2.0使用了tls的拓展ALPN做为协议升级。

**参考**：

- [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://www.cnblogs.com/heluan/p/8620312.html)

- [一篇文章让你入门HTTP2.0](https://segmentfault.com/a/1190000016656529?utm_source=tag-newest)

---

## NAT（网络地址转换）

它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。

==NAT缓解了IPV4地址不够用的问题，同时也带了限制，那就是NAT外部的主机无法主动跟位于NAT内部的主机通信，NAT内部主机想要通信，必须主动和公网的一个IP通信，路由器负责建立一个映射关系，从而实现数据的转发， 这就是NAT的工作原理。==

- 静态 NAT：将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。

- 动态 NAT：指不建立内部地址和全局地址的一对一的固定对应关系。而通过共享NAT地址池的IP地址动态建立NAT的映射关系。当内网主机需要进行NAT地址转换时，路由器会在NAT地址池中选择空闲的全局地址进行映射，每条映射记录是动态建立的，在连接终止时也被收回。

- 网络地址端口转换NAPT：把内部地址映射到外部网络的一个IP地址的不同端口上。它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。

    1. 锥形 NAT：又分为全锥形、受限锥形、端口受限锥形

    2. 对称 NAT：

    ==锥形和非锥形链接二讲的很清楚==

**参考**：

- [NAT(地址转换技术)详解](https://blog.csdn.net/gui951753/article/details/79593307)

- [NAT的四种类型](https://blog.csdn.net/eydwyz/article/details/87364157)

---

## UDP 打洞

1、双方都通过UDP与服务器通讯后，网关默认就是做了一个外网IP和端口号 与你内网IP与端口号的映射，这个无需设置的，服务器也不需要知道客户的真正内网IP

2、用户A先通过服务器知道用户B的外网地址与端口  

3、用户A向用户B的外网地址与端口发送消息，  

4、在这一次发送中，用户B的网关会拒收这条消息，因为它的映射中并没有这条规则。  

5、但是用户A的网关就会增加了一条允许规则，允许接收从B发送过来的消息  

6、服务器要求用户B发送一个消息到用户A的外网IP与端口号  

7、用户B发送一条消息，这时用户A就可以接收到B的消息，而且网关B也增加了允许规则  

8、之后，由于网关A与网关B都增加了允许规则，所以A与B都可以向对方的外网IP和端口号发送消息。

![image.png](https://ww1.sinaimg.cn/large/006alGmrgy1geejdd4mj7j30s60hhai1.jpg)

**参考**：

- [NAT穿透（UDP打洞）](https://www.cnblogs.com/GO-NO-1/p/7241556.html)

---

## TCP 打洞

==和UDP打洞有区别==

 UDP的socket允许多个socket绑定到同一个本地端口，而TCP的socket则不允许。
    这是这样一个意思：A B要连接到S，肯定首先A B双方都会在本地创建一个socket，
去连接S上的socket。创建一个socket必然会绑定一个本地端口（就算应用程序里面没写
端口，实际上也是绑定了的，至少java确实如此），假设为8888，这样A和B才分别建立了到
S的通信信道。接下来就需要打洞了，打洞则需要A和B分别发送数据包到对方的公网IP。但是
问题就在这里：因为NAT设备是根据端口号来确定session，如果是UDP的socket，A B可以
分别再创建socket，然后将socket绑定到8888，这样打洞就成功了。但是如果是TCP的
socket，则不能再创建socket并绑定到8888了，这样打洞就无法成功。

**具体参考链接**：

**参考**：

- [NAT穿透（UDP打洞）](https://www.cnblogs.com/GO-NO-1/p/7241556.html)

---

## 交换机、路由器和网关

- 交换机：可以用局域网、IP稀缺

    交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。

    交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。

- 路由器：路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。
    ==路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路==。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。

- 网关：网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。

**网关和路由器的区别**：‘网关’一个大概念，不具体特指一类产品，==只要连接两个不同的网络的设备都可以叫网关==；==而‘路由器’么一般特指能够实现路由寻找和转发的特定类产品，路由器很显然能够实现网关的功能。==

**参考**：

- [了解交换机、路由器、网关的概念，并知道各自的用途](https://www.nowcoder.com/ta/review-network/review?tpId=33&tqId=21199&query=&asc=true&order=&page=11)

- [网关和路由器的区别是什么？](https://www.zhihu.com/question/21787311)

---

## 冲突域和广播域

- 冲突域：冲突域就是连接在同一导线上的所有工作站的集合。冲突域指的是会产生冲突的最小范围，在计算机和计算机通过设备互联时，会建立一条通道，如果这条通道只允许瞬间一个数据报文通过，那么在同时如果有两个或更多的数据报文想从这里通过时就会出现冲突了。

    多口hub的冲突域只有一个，但是冲突域比较大，所有的端口上的数据报文都要排队等待通过。交换机的冲突域有多个，但是每个冲突域比较小（每一个端口都是一个冲突域，即一个或多个端口的高速传输不会影响其它端口的传输，因为所有的数据报文不同都按次序排队通过，而只是到同一端口的数据才要排队。）

    ==冲突域数量多，但是小（不过也带来了地址段太多，管理不便的缺点），优于冲突域数量少，但是大==

- 广播域：指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为广播域(Broadcast Domain)

**广播域与冲突域的区别**：

- 广播域可以跨网段，而冲突域只是发生的同一个网段的

- 冲突域基于第一层（物理层）；广播域基于第二层（数据链路层）

- 集线器（HUB）（==位于物理层==）所有端口都在同一个广播域，冲突域内；第二层交换机（Swith）所有端口都在同一个广播域内，而每一个端口就是一个冲突域。

**参考**：

- [冲突域和广播域](https://blog.csdn.net/cwl421/article/details/49639399/)

- [在局域网中，冲突域的数量越多越好，还是越少越好](https://zhidao.baidu.com/question/1366541984607487859.html)

---

## ARP地址解析协议（Address Resolution Protocol）

提供将 IP 地址转换为链路层地址（mac）的机制

ARP 与 DNS 的区别：ARP 只为在同一个子网上的主机和路由器接口解析 IP 地址，而 DNS 为在因特网中的任何地方的主机解析主机名。

==在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层==。

**参考**：

- [TCP/IP OSI各层协议，ARP属于哪一层的协议](https://blog.csdn.net/cuiweitju/article/details/38761381)

- [ARP协议原理](https://blog.csdn.net/jiejiemcu/article/details/88406088)

---

## 表示层与会话层

表示层：数据的表现形式、特定功能的实现，如 - 加密；协议有：TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption

会话层：对应用会话进行管理与同步；协议有：RPC，SQL，NFS，NetBIOS，names，AppleTalk

**参考**：

- [OSI七层模型的每一层都有哪些协议？谢谢！](https://zhidao.baidu.com/question/26454391.html)

---

## web 攻击

- 主动攻击：主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。

  主动攻击模式里具有代表性的攻击是 **SQL 注入攻击**和**OS 命令注入攻击**。

- 被动攻击：被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。

  被动攻击通常的攻击模式如下所示：

  步骤 1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。
  步骤 2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。
  步骤 3： 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。
  步骤 4： 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，**可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果**。

  被动攻击模式中具有代表性的攻击是**跨站脚本攻击**和**跨站点请求伪造**。